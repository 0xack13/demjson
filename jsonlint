#!/usr/bin/env python
# -*- coding: utf-8 -*-
r"""A JSON syntax validator and formatter tool.

Requires demjson module.

"""
__author__ = "Deron Meranda <http://deron.meranda.us/>"
__date__ = "2014-04-13"
__version__ = "1.7"
__homepage__ = "http://deron.meranda.us/python/demjson/"
__credits__ = """Copyright (c) 2006-2014 Deron E. Meranda <http://deron.meranda.us/>

Licensed under GNU LGPL (GNU Lesser General Public License) version 3.0
or later.  See LICENSE.txt included with this software.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
or <http://www.fsf.org/licensing/>.

"""

program_name = "jsonlint"

import sys,os

try:
    import demjson
except ImportError:
    sys.stderr.write("Can not import the demjson Python module.\n")
    sys.stderr.write("Try running:  pip install demjson\n")
    sys.exit(1)



def lintcheck_data( jsondata, verbose_fp=None, strict=True,
                    reformat=False,
                    input_encoding=None, output_encoding=None, escape_unicode=True,
                    pfx='' ):
    success = False
    reformatted = None
    try:
        data = demjson.decode(jsondata, strict=strict, encoding=input_encoding)
    except demjson.JSONError, err:
        success = False
        if verbose_fp:
            verbose_fp.write('%s%s\n' % (pfx, err.pretty_description()) )
    except UnicodeDecodeError, err:
        success = False
        if verbose_fp:
            verbose_fp.write('%sFile is not text: %s\n' % (pfx, str(err) ))
    else:
        success = True
        if reformat == 'compactly':
            reformatted = demjson.encode(data, compactly=True, encoding=output_encoding, escape_unicode=escape_unicode)
        elif reformat:
            reformatted = demjson.encode(data, compactly=False, encoding=output_encoding, escape_unicode=escape_unicode)
    return (success, reformatted)


def lintcheck( filename, output_filename, verbose=False, strict=True, reformat=False,
               input_encoding=None, output_encoding=None, escape_unicode=True ):
    verbose_fp = None

    if not filename or filename == "-":
        pfx = '<stdin>: '
        jsondata = sys.stdin.read()
        if verbose:
            verbose_fp = sys.stderr
    else:
        pfx = '%s: ' % filename
        try:
            fp = open( filename, 'rb' )
            jsondata = fp.read()
            fp.close()
        except IOError, err:
            sys.stderr.write('%s: %s\n' % (pfx, str(err)) )
            return False
        if verbose:
            verbose_fp = sys.stdout

    success, reformatted = lintcheck_data( jsondata, verbose_fp=verbose_fp,
                                           strict=strict,
                                           reformat=reformat,
                                           input_encoding=input_encoding, output_encoding=output_encoding,
                                           escape_unicode=escape_unicode,
                                           pfx=pfx )
    if success and reformat:
        if output_filename:
            try:
                fp = open( output_filename, 'wb' )
                fp.write( reformatted )
            except IOError, err:
                sys.stderr.write('%s: %s\n' % (pfx, str(err)) )
                success = False
        else:
            sys.stdout.write( reformatted )
    elif success and verbose_fp:
        verbose_fp.write('%sok\n' % pfx)

    return success


# --------------------
main_usage = """Usage: %(program_name)s [<options> ...] inputfile.json ...

With no input filename, or "-", it will read from standard input.

The return status will be 0 if the file is conforming JSON (per the
RFC 7158 specification), or non-zero otherwise.

OPTIONS:

 -v | --verbose    Show details of lint checking
 -q | --quiet      Don't show any warnings

 -s | --strict     Be strict in what is considered conforming JSON (the default)
 -S | --nonstrict  Be loose in what is considered conforming JSON

 -f | --format     Reformat the JSON text (if conforming) to stdout
 -F | --format-compactly
        Reformat the JSON simlar to -f, but do so compactly by
        removing all unnecessary whitespace
 -o filename | --output filename
        The filename to which reformatted JSON is to be written.
        Without this option the standard output is used.

UNICODE OPTIONS:

 -e codec | --encoding=codec     Set both input and output encodings
 --input-encoding=codec          Set the input encoding
 --output-encoding=codec         Set the output encoding

    These options set the character encoding codec (e.g., "ascii",
    "utf-8", "utf-16").  The -e will set both the input and output
    encodings to the same thing.  The output encoding is used when
    reformatting with the -f or -F options.

    Unless set, the input encoding is guessed and the output
    encoding will be "utf-8".

REFORMATTING:

    When reformatting JSON with -f or -F, output is only produced if
    the input passed validation.  By default the reformatted JSON will
    be written to standard output, unless the -o option was given.

    The default output codec is UTF-8, unless an encoding option is
    provided.  Any Unicode characters will be output as literal
    characters if the encoding permits, otherwise they will be
    \u-escaped.  You can use "--output-encoding ascii" to force all
    Unicode characters to be escaped.

MORE INFORMATION:

    Use '%(program_name)s --version [-v]' to see versioning information.
    Use '%(program_name)s --copyright' to see author and copyright details.'

    %(program_name)s is distributed as part of the "demjson" Python module.
    See %(homepage)s
"""

def main( args ):
    import getopt
    success = True
    verbose = 'auto'  # one of 'auto', True, or False
    strict = True
    reformat = False
    output_filename = None
    input_encoding = None
    output_encoding = 'utf-8'
    escape_unicode = False

    try:
        opts, args = getopt.getopt( args,
                                    'vqfFe:o:sS',
                                    ['verbose','quiet',
                                     'format','format-compactly',
                                     'output',
                                     'strict','nonstrict',
                                     'encoding=',
                                     'input-encoding=','output-encoding=',
                                     'help','version','copyright'] )
    except getopt.GetoptError, err:
        sys.stderr.write( "Error: %s.  Use \"%s --help\" for usage information.\n" % (err.msg,program_name) )
        return 1

    # Set verbose before looking at any other options
    for opt, val in opts:
        if opt in ('-v', '--verbose'):
            verbose=True

    # Process all options
    for opt, val in opts:
        if opt in ('-h', '--help'):
            sys.stdout.write( main_usage % {'program_name':program_name, 'homepage':__homepage__} )
            return 0
        elif opt == '--version':
            sys.stdout.write( '%s version %s (%s)\n' % (program_name, __version__, __date__) )
            sys.stdout.write( 'demjson version %s (%s)\n' % (demjson.__version__, demjson.__date__)  )
            if verbose == True and hasattr(demjson,'__file__'):
                sys.stdout.write( 'demjson from %r\n' % (demjson.__file__,) )
            if verbose == True:
                sys.stdout.write( 'Python version: %s\n' % (sys.version.replace('\n',' '),) )
                sys.stdout.write( 'Python max unicode: U+%X\n' % (sys.maxunicode,) )
            return 0
        elif opt == '--copyright':
            sys.stdout.write( "%s is distributed as part of the \"demjson\" python package.\n", (program_name,) )
            sys.stdout.write( "See %s\n\n\n" % (__homepage__,) )
            sys.stdout.write( __credits__ )
            return 0
        elif opt in ('-v', '--verbose'):
            verbose = True
        elif opt in ('-q', '--quiet'):
            verbose = False
        elif opt in ('-s', '--strict'):
            strict = True
        elif opt in ('-S', '--nonstrict'):
            strict = False
        elif opt in ('-f', '--format'):
            reformat = True
        elif opt in ('-F', '--format-compactly'):
            reformat = 'compactly'
        elif opt in ('-o', '--output'):
            output_filename = val
        elif opt in ('-e','--encoding'):
            input_encoding = val
            output_encoding = val
            escape_unicode = False
        elif opt in ('--output-encoding'):
            output_encoding = val
            escape_unicode = False
        elif opt in ('--input-encoding'):
            input_encoding = val
        else:
            sys.stderr.write('Unknown option %r\n' % opt)
            return 1
            
    if not args:
        args = [None]

    for fn in args:
        if not lintcheck( fn, output_filename=output_filename,
                          verbose=verbose, reformat=reformat,
                          strict=strict,
                          input_encoding=input_encoding,
                          output_encoding=output_encoding,
                          escape_unicode=escape_unicode ):
            success = False

    if not success:
        return 1
    return 0


if __name__ == '__main__':
    program_name = os.path.basename(sys.argv[0])
    args = sys.argv[1:]
    rc = main( args )
    sys.exit(rc)
