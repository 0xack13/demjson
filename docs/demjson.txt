Help on module demjson:

NAME
    demjson - A JSON data encoder and decoder.

FILE
    demjson.py

DESCRIPTION
    This Python module implements the JSON (http://json.org/) data
    encoding format; a subset of ECMAScript (aka JavaScript) for encoding
    primitive data types (numbers, strings, booleans, lists, and
    associative arrays) in a language-neutral simple text-based syntax.
    
    It can encode or decode between JSON formatted strings and native
    Python data types.  Normally you would use the encode() and decode()
    functions defined by this module, but if you want more control over
    the processing you can use the JSON class.
    
    This implementation tries to be as completely cormforming to all
    intricacies of the standards as possible.  It can operate in strict
    mode (which only allows JSON-compliant syntax) or a non-strict mode
    (which allows much more of the whole ECMAScript permitted syntax).
    This includes complete support for Unicode strings (including
    surrogate-pairs for non-BMP characters), and all number formats
    including negative zero and IEEE 754 non-numbers such a NaN or
    Infinity.
    
    The JSON/ECMAScript to Python type mappings are:
       ---JSON---             ---Python---
       null                   None
       undefined              undefined  (note 1)
       Boolean (true,false)   bool  (True or False)
       Integer                int or long  (note 2)
       Float                  float
       String                 str or unicode  ( "..." or u"..." )
       Array [a, ...]         list  ( [...] )
       Object {a:b, ...}      dict  ( {...} )
       
       -- Note 1. an 'undefined' object is declared in this module which
          represents the native Python value for this type when in
          non-strict mode.
    
       -- Note 2. some ECMAScript integers may be up-converted to Python
          floats, such as 1e+40.  Also integer -0 is converted to
          float -0, so as to preserve the sign (which ECMAScript requires).
    
       -- Note 3. numbers requiring more significant digits than can be
          represented by the Python float type will be converted into a
          Python Decimal type, from the standard 'decimal' module.
    
    In addition, when operating in non-strict mode, several IEEE 754
    non-numbers are also handled, and are mapped to specific Python
    objects declared in this module:
    
        NaN (not a number)     nan    (float('nan'))
        Infinity, +Infinity    inf    (float('inf'))
        -Infinity              neginf (float('-inf'))
    
    When encoding Python objects into JSON, you may use types other than
    native lists or dictionaries, as long as they support the minimal
    interfaces required of all sequences or mappings.  This means you can
    use generators and iterators, tuples, UserDict subclasses, etc.
    
    To make it easier to produce JSON encoded representations of user
    defined classes, if the object has a method named json_equivalent(),
    then it will call that method and attempt to encode the object
    returned from it instead.  It will do this recursively as needed and
    before any attempt to encode the object using it's default
    strategies.  Note that any json_equivalent() method should return
    "equivalent" Python objects to be encoded, not an already-encoded
    JSON-formatted string.  There is no such aid provided to decode
    JSON back into user-defined classes as that would dramatically
    complicate the interface.
    
    When decoding strings with this module it may operate in either
    strict or non-strict mode.  The strict mode only allows syntax which
    is conforming to RFC 7158 (JSON), while the non-strict allows much
    more of the permissible ECMAScript syntax.
    
    The following are permitted when processing in NON-STRICT mode:
    
       * Unicode format control characters are allowed anywhere in the input.
       * All Unicode line terminator characters are recognized.
       * All Unicode white space characters are recognized.
       * The 'undefined' keyword is recognized.
       * Hexadecimal number literals are recognized (e.g., 0xA6, 0177).
       * String literals may use either single or double quote marks.
       * Strings may contain \x (hexadecimal) escape sequences, as well as the
         \v and \0 escape sequences.
       * Lists may have omitted (elided) elements, e.g., [,,,,,], with
         missing elements interpreted as 'undefined' values.
       * Object properties (dictionary keys) can be of any of the
         types: string literals, numbers, or identifiers (the later of
         which are treated as if they are string literals)---as permitted
         by ECMAScript.  JSON only permits strings literals as keys.
    
    Concerning non-strict and non-ECMAScript allowances:
    
       * Octal numbers: If you allow the 'octal_numbers' behavior (which
         is never enabled by default), then you can use octal integers
         and octal character escape sequences (per the ECMAScript
         standard Annex B.1.2).  This behavior is allowed, if enabled,
         because it was valid JavaScript at one time.
    
       * Multi-line string literals:  Strings which are more than one
         line long (contain embedded raw newline characters) are never
         permitted. This is neither valid JSON nor ECMAScript.  Some other
         JSON implementations may allow this, but this module considers
         that behavior to be a mistake.
    
    References:
       * JSON (JavaScript Object Notation)
         <http://json.org/>
       * RFC 7158. The application/json Media Type for JavaScript Object Notation (JSON)
         <http://www.ietf.org/rfc/rfc7158.txt>
       * ECMA-262 3rd edition (1999)
         <http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf>
       * IEEE 754-1985: Standard for Binary Floating-Point Arithmetic.
         <http://www.cs.berkeley.edu/~ejr/Projects/ieee754/>

CLASSES
    __builtin__.object
        JSON
        helpers
        jsonlint
    codecs.CodecInfo(__builtin__.tuple)
        utf32
    exceptions.Exception(exceptions.BaseException)
        JSONSkipHook
    exceptions.ValueError(exceptions.StandardError)
        JSONError
            JSONDecodeError
                JSONDecodeHookError
            JSONEncodeError
                JSONEncodeHookError
    
    class JSON(__builtin__.object)
     |  An encoder/decoder for JSON data streams.
     |  
     |  Usually you will call the encode() or decode() methods.  The other
     |  methods are for lower-level processing.
     |  
     |  Whether the JSON parser runs in strict mode (which enforces exact
     |  compliance with the JSON spec) or the more forgiving non-string mode
     |  can be affected by setting the 'strict' argument in the object's
     |  initialization; or by assigning True or False to the 'strict'
     |  property of the object.
     |  
     |  You can also adjust a finer-grained control over strictness by
     |  allowing or preventing specific behaviors.  You can get a list of
     |  all the available behaviors by accessing the 'behaviors' property.
     |  Likewise the allowed_behaviors and prevented_behaviors list which
     |  behaviors will be allowed and which will not.  Call the allow()
     |  or prevent() methods to adjust these.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, strict=False, compactly=True, escape_unicode=False, encode_namedtuple_as_object=True)
     |      Creates a JSON encoder/decoder object.
     |      
     |      If 'strict' is set to True, then only strictly-conforming JSON
     |      output will be produced.  Note that this means that some types
     |      of values may not be convertable and will result in a
     |      JSONEncodeError exception.
     |      
     |      If 'compactly' is set to True, then the resulting string will
     |      have all extraneous white space removed; if False then the
     |      string will be "pretty printed" with whitespace and indentation
     |      added to make it more readable.
     |      
     |      If 'escape_unicode' is set to True, then all non-ASCII characters
     |      will be represented as a unicode escape sequence; if False then
     |      the actual real unicode character will be inserted if possible.
     |      
     |      The 'escape_unicode' can also be a function, which when called
     |      with a single argument of a unicode character will return True
     |      if the character should be escaped or False if it should not.
     |      
     |      If you wish to extend the encoding to ba able to handle
     |      additional types, you may either:
     |      
     |            * subclass this class and override the encode_default()
     |              method, or
     |      
     |            * set an 'encode_default' hook function (see set_hook())
     |      
     |      If 'encode_namedtuple_as_object' is True, then objects of type
     |      namedtuple, or subclasses of 'tuple' that have an _asdict()
     |      method, will be encoded as an object rather than an array.
     |  
     |  allow(self, behavior)
     |      Allow the specified behavior (turn off a strictness check).
     |      
     |      The list of all possible behaviors is available in the behaviors property.
     |      You can see which behaviors are currently allowed by accessing the
     |      allowed_behaviors property.
     |  
     |  call_hook(self, hook_name, *args, **kwargs)
     |  
     |  clear_all_hooks(self)
     |      Unsets all hook callbacks, as previously set with set_hook().
     |  
     |  clear_hook(self, hookname)
     |      Unsets a hook callback, as previously set with set_hook().
     |  
     |  decode(self, txt)
     |      Decodes a JSON-endoded string into a Python object.
     |  
     |  decode_boolean(self, s, i=0)
     |      Intermediate-level decode for JSON boolean literals.
     |      
     |      Takes a string and a starting index, and returns a Python bool
     |      (True or False) and the index of the next unparsed character.
     |  
     |  decode_composite(self, txt, i=0, imax=None)
     |      Intermediate-level JSON decoder for composite literal types (array and object).
     |      
     |      Takes text and a starting index, and returns either a Python list or
     |      dictionary and the index of the next unparsed character.
     |  
     |  decode_javascript_identifier(self, name)
     |      Convert a JavaScript identifier into a Python string object.
     |      
     |      This method can be overriden by a subclass to redefine how JavaScript
     |      identifiers are turned into Python objects.  By default this just
     |      converts them into strings.
     |  
     |  decode_null(self, s, i=0)
     |      Intermediate-level decoder for ECMAScript 'null' keyword.
     |      
     |      Takes a string and a starting index, and returns a Python
     |      None object and the index of the next unparsed character.
     |  
     |  decode_number(self, s, i=0, imax=None)
     |      Intermediate-level decoder for JSON numeric literals.
     |      
     |      Takes a string and a starting index, and returns a Python
     |      suitable numeric type and the index of the next unparsed character.
     |      
     |      The returned numeric type can be either of a Python int,
     |      long, or float.  In addition some special non-numbers may
     |      also be returned such as nan, inf, and neginf (technically
     |      which are Python floats, but have no numeric value.)
     |      
     |      Ref. ECMAScript section 8.5.
     |  
     |  decode_string(self, s, i=0, imax=None)
     |      Intermediate-level decoder for JSON string literals.
     |      
     |      Takes a string and a starting index, and returns a Python
     |      string (or unicode string) and the index of the next unparsed
     |      character.
     |  
     |  decodeobj(self, txt, i=0, imax=None, identifier_as_string=False, only_object_or_array=False)
     |      Intermediate-level JSON decoder.
     |      
     |      Takes a string and a starting index, and returns a two-tuple consting
     |      of a Python object and the index of the next unparsed character.
     |      
     |      If there is no value at all (empty string, etc), the None is
     |      returned instead of a tuple.
     |  
     |  encode(self, obj, nest_level=0)
     |      Encodes the Python object into a JSON string representation.
     |      
     |      This method will first attempt to encode an object by seeing
     |      if it has a json_equivalent() method.  If so than it will
     |      call that method and then recursively attempt to encode
     |      the object resulting from that call.
     |      
     |      Next it will attempt to determine if the object is a native
     |      type or acts like a squence or dictionary.  If so it will
     |      encode that object directly.
     |      
     |      Finally, if no other strategy for encoding the object of that
     |      type exists, it will call the encode_default() method.  That
     |      method currently raises an error, but it could be overridden
     |      by subclasses to provide a hook for extending the types which
     |      can be encoded.
     |  
     |  encode_boolean(self, b)
     |      Encodes the Python boolean into a JSON Boolean literal.
     |  
     |  encode_composite(self, chunklist, obj, nest_level, obj_classification=None)
     |      Encodes just dictionaries, lists, or sequences.
     |      
     |      Basically handles any python type for which iter() can create
     |      an iterator object.
     |      
     |      This method is not intended to be called directly.  Use the
     |      encode() method instead.
     |  
     |  encode_default(self, obj, nest_level=0)
     |      DEPRECATED.
     |      
     |      This method is used to encode objects into JSON which are not straightforward.
     |      
     |      This method is intended to be overridden by subclasses which wish
     |      to extend this encoder to handle additional types.
     |  
     |  encode_equivalent(self, obj, nest_level=0)
     |      This method is used to encode user-defined class objects.
     |      
     |      The object being encoded should have a json_equivalent()
     |      method defined which returns another equivalent object which
     |      is easily JSON-encoded.  If the object in question has no
     |      json_equivalent() method available then None is returned
     |      instead of a string so that the encoding will attempt the next
     |      strategy.
     |      
     |      If a caller wishes to disable the calling of json_equivalent()
     |      methods, then subclass this class and override this method
     |      to just return None.
     |  
     |  encode_helper(self, chunklist, obj, nest_level)
     |  
     |  encode_null(self)
     |      Produces the JSON 'null' keyword.
     |  
     |  encode_number(self, n)
     |      Encodes a Python numeric type into a JSON numeric literal.
     |      
     |      The special non-numeric values of float('nan'), float('inf')
     |      and float('-inf') are translated into appropriate JSON
     |      literals.
     |      
     |      Note that Python complex types are not handled, as there is no
     |      ECMAScript equivalent type.
     |  
     |  encode_string(self, s)
     |      Encodes a Python string into a JSON string literal.
     |  
     |  encode_undefined(self)
     |      Produces the ECMAScript 'undefined' keyword.
     |  
     |  has_hook(self, hook_name)
     |  
     |  islineterm(self, c)
     |      Determines if the given character is considered a line terminator.
     |      
     |      Ref. ECMAScript section 7.3
     |  
     |  isws(self, c)
     |      Determines if the given character is considered as white space.
     |      
     |      Note that Javscript is much more permissive on what it considers
     |      to be whitespace than does JSON.
     |      
     |      Ref. ECMAScript section 7.2
     |  
     |  prevent(self, behavior)
     |      Prevent the specified behavior (turn on a strictness check).
     |      
     |      The list of all possible behaviors is available in the behaviors property.
     |      You can see which behaviors are currently prevented by accessing the
     |      prevented_behaviors property.
     |  
     |  set_hook(self, hookname, function)
     |      Sets a user-defined callback function used during encoding or decoding.
     |      
     |      The 'hookname' argument must be a string containing the name of
     |      one of the available hooks, listed below.
     |      
     |      The 'function' argument must either be None, which disables the hook,
     |      or a callable function.  Hooks do not stack, if you set a hook it will
     |      undo any previously set hook.
     |      
     |      Netsted values.  When decoding JSON that has nested objects or
     |      arrays, the decoding hooks will be called once for every
     |      corresponding value, even if nested.  Generally the decoding
     |      hooks will be called from the inner-most value outward, and
     |      then left to right.
     |      
     |      Skipping. Any hook function may raise a JSONSkipHook exception
     |      if it does not wish to handle the particular invocation.  This
     |      will have the effect of skipping the hook for that particular
     |      value, as if the hook was net set.
     |      
     |      AVAILABLE HOOKS:
     |      
     |      * decode_string
     |          Called for every JSON string literal with the
     |          Python-equivalent string value as an argument. Expects to
     |          get a Python object in return.
     |      
     |      * decode_float:
     |          Called for every JSON number that looks like a float (has
     |          a ".").  The string representation of the number is passed
     |          as an argument.  Expects to get a Python object in return.
     |      
     |      * decode_number:
     |          Called for every JSON number. The string representation of
     |          the number is passed as an argument.  Expects to get a
     |          Python object in return.  NOTE: If the number looks like a
     |          float and the 'decode_float' hook is set, then this hook
     |          will not be called.
     |      
     |      * decode_array:
     |          Called for every JSON array. A Python list is passed as
     |          the argument, and expects to get a Python object back.
     |          NOTE: this hook will get called for every array, even
     |          for nested arrays.
     |      
     |      * decode_object:
     |          Called for every JSON object.  A Python dictionary is passed
     |          as the argument, and expects to get a Python object back.
     |          NOTE: this hook will get called for every object, even
     |          for nested objects.
     |      
     |      * encode_value:
     |          Called for every Python object which is to be encoded into JSON.
     |      
     |      * encode_dict:
     |          Called for every Python dictionary or anything that looks
     |          like a dictionary.
     |      
     |      * encode_dict_key:
     |          Called for every dictionary key.
     |      
     |      * encode_sequence:
     |          Called for every Python sequence-like object that is not a
     |          dictionary or string. This includes lists and tuples.
     |      
     |      * encode_bytes:
     |          Called for every Python bytes or bytearray type; or for
     |          any memoryview with a byte ('B') item type.  (Python 3 only)
     |      
     |      * encode_default:
     |          Called for any Python type which can not otherwise be converted
     |          into JSON, even after applying any other encoding hooks.
     |  
     |  skip_comment(self, txt, i=0)
     |      Skips an ECMAScript comment, either // or /* style.
     |      
     |      The contents of the comment are returned as a string, as well
     |      as the index of the character immediately after the comment.
     |  
     |  skipws(self, txt, i=0, imax=None, skip_comments=True)
     |      Skips whitespace.
     |  
     |  skipws_any(self, txt, i=0, imax=None, skip_comments=True)
     |      Skips all whitespace, including comments and unicode whitespace
     |      
     |      Takes a string and a starting index, and returns the index of the
     |      next non-whitespace character.
     |      
     |      If skip_comments is True and not running in strict JSON mode, then
     |      comments will be skipped over just like whitespace.
     |  
     |  try_encode_default(self, obj, nest_level=0)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  allowed_behaviors
     |      List of known behaviors that are currently allowed
     |  
     |  behaviors
     |      List of known behaviors that can be passed to allow() or prevent() methods
     |  
     |  prevented_behaviors
     |      List of known behaviors that are currently prevented
     |  
     |  strict
     |      True if adherence to RFC 7158 syntax is strict, or False is more generous ECMAScript syntax is permitted
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  all_hook_names = ('decode_number', 'decode_float', 'decode_object', 'd...
     |  
     |  json_syntax_characters = u'{}[]"\\,:0123456789.-+abcdefghijklmnopqrstu...
    
    class JSONDecodeError(JSONError)
     |  An exception class raised when a JSON decoding error (syntax error) occurs.
     |  
     |  Method resolution order:
     |      JSONDecodeError
     |      JSONError
     |      exceptions.ValueError
     |      exceptions.StandardError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods inherited from JSONError:
     |  
     |  pretty_description(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from JSONError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.ValueError:
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see help(type(x)) for signature
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.ValueError:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class JSONDecodeHookError(JSONDecodeError)
     |  An exception that occured within a decoder hook.
     |  
     |  The original exception is available in the 'hook_exception' attribute.
     |  
     |  Method resolution order:
     |      JSONDecodeHookError
     |      JSONDecodeError
     |      JSONError
     |      exceptions.ValueError
     |      exceptions.StandardError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, hook_name, exc_info, encoded_obj, *args, **kwargs)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from JSONError:
     |  
     |  pretty_description(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from JSONError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.ValueError:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class JSONEncodeError(JSONError)
     |  An exception class raised when a python object can not be encoded as a JSON string.
     |  
     |  Method resolution order:
     |      JSONEncodeError
     |      JSONError
     |      exceptions.ValueError
     |      exceptions.StandardError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods inherited from JSONError:
     |  
     |  pretty_description(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from JSONError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.ValueError:
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see help(type(x)) for signature
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.ValueError:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class JSONEncodeHookError(JSONEncodeError)
     |  An exception that occured within an encoder hook.
     |  
     |  The original exception is available in the 'hook_exception' attribute.
     |  
     |  Method resolution order:
     |      JSONEncodeHookError
     |      JSONEncodeError
     |      JSONError
     |      exceptions.ValueError
     |      exceptions.StandardError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, hook_name, exc_info, encoded_obj, *args, **kwargs)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from JSONError:
     |  
     |  pretty_description(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from JSONError:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.ValueError:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class JSONError(exceptions.ValueError)
     |  Our base class for all JSON-related errors.
     |  
     |  Method resolution order:
     |      JSONError
     |      exceptions.ValueError
     |      exceptions.StandardError
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  pretty_description(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.ValueError:
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see help(type(x)) for signature
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.ValueError:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class JSONSkipHook(exceptions.Exception)
     |  An exception to be raised by user-defined code within hook
     |  callbacks to indicate the callback does not want to handle the
     |  situation.
     |  
     |  Method resolution order:
     |      JSONSkipHook
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.Exception:
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see help(type(x)) for signature
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.Exception:
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class helpers(__builtin__.object)
     |  A set of utility functions.
     |  
     |  Static methods defined here:
     |  
     |  auto_detect_encoding(s)
     |      Takes a string (or byte array) and tries to determine the Unicode encoding it is in.
     |      
     |      Returns the encoding name, as a string.
     |  
     |  auto_unicode_decode(s)
     |      Takes a string (or byte array) and tries to convert it to a Unicode string.
     |      
     |      This will return a Python unicode string type corresponding to the
     |      input string (either str or unicode).  The character encoding is
     |      guessed by looking for either a Unicode BOM prefix, or by the
     |      rules specified by RFC 7158.  When in doubt it is assumed the
     |      input is encoded in UTF-8 (the default for JSON).
     |      
     |      The BOM (byte order mark) if present will be stripped off of the
     |      returned string.
     |  
     |  char_is_identifier_leader(c)
     |      Determines if the character may be the first character of a
     |      JavaScript identifier.
     |  
     |  char_is_identifier_tail(c)
     |      Determines if the character may be part of a JavaScript
     |      identifier.
     |  
     |  char_is_json_eol(c)
     |      Determines if the given character is a JSON line separator
     |  
     |  char_is_json_ws(c)
     |      Determines if the given character is a JSON white-space character
     |  
     |  char_is_unicode_eol(c)
     |      Determines if the given character is a Unicode line or
     |      paragraph separator. These correspond to CR and LF as well as
     |      Unicode characters in the Zl or Zp categories.
     |  
     |  char_is_unicode_ws(c)
     |      Determines if the given character is a Unicode space character
     |  
     |  decode_hex(hexstring)
     |      Decodes a hexadecimal string into it's integer value.
     |  
     |  decode_octal(octalstring)
     |      Decodes an octal string into it's integer value.
     |  
     |  extend_and_flatten_list_with_sep(orig_seq, extension_seq, separator='')
     |  
     |  is_hex_digit(c)
     |      Determines if the given character is a valid hexadecimal digit (0-9, a-f, A-F).
     |  
     |  is_octal_digit(c)
     |      Determines if the given character is a valid octal digit (0-7).
     |  
     |  isnumbertype(obj)
     |      Is the object of a Python number type (excluding complex)?
     |  
     |  isstringtype(obj)
     |      Is the object of a Python string type?
     |  
     |  lookup_codec(encoding)
     |      Wrapper around codecs.lookup().
     |      
     |      Returns None if codec not found, rather than raising a LookupError.
     |  
     |  make_raw_bytes(byte_list)
     |      Constructs a byte array (bytes in Python 3, str in Python 2) from a list of byte values (0-255).
     |  
     |  strip_format_control_chars(txt)
     |      Filters out all Unicode format control characters from the string.
     |      
     |      ECMAScript permits any Unicode "format control characters" to
     |      appear at any place in the source code.  They are to be
     |      ignored as if they are not there before any other lexical
     |      tokenization occurs.  Note that JSON does not allow them,
     |      except within string literals.
     |      
     |      * Ref. ECMAScript section 7.1.
     |      * http://en.wikipedia.org/wiki/Unicode_control_characters
     |      
     |      There are dozens of Format Control Characters, for example:
     |          U+00AD   SOFT HYPHEN
     |          U+200B   ZERO WIDTH SPACE
     |          U+2060   WORD JOINER
     |  
     |  surrogate_pair_as_unicode(c1, c2)
     |      Takes a pair of unicode surrogates and returns the equivalent unicode character.
     |      
     |      The input pair must be a surrogate pair, with c1 in the range
     |      U+D800 to U+DBFF and c2 in the range U+DC00 to U+DFFF.
     |  
     |  unicode_as_surrogate_pair(c)
     |      Takes a single unicode character and returns a sequence of surrogate pairs.
     |      
     |      The output of this function is a tuple consisting of one or two unicode
     |      characters, such that if the input character is outside the BMP range
     |      then the output is a two-character surrogate pair representing that character.
     |      
     |      If the input character is inside the BMP then the output tuple will have
     |      just a single character...the same one.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  always_use_custom_codecs = False
     |  
     |  hexdigits = '0123456789ABCDEFabcdef'
     |  
     |  octaldigits = '01234567'
     |  
     |  unsafe_string_chars = u'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x...
    
    class jsonlint(__builtin__.object)
     |  This class contains most of the logic for the "jsonlint" command.
     |  
     |  You generally create an instance of this class, to defined the
     |  program's environment, and then call the main() method.  A simple
     |  wrapper to turn this into a script might be:
     |  
     |      import sys, demjson
     |      if __name__ == '__main__':
     |          lint = demjson.jsonlint( sys.argv[0] )
     |          return lint.main( sys.argv[1:] )
     |  
     |  Methods defined here:
     |  
     |  __init__(self, program_name='jsonlint', stdin=None, stdout=None, stderr=None)
     |      Create an instance of a "jsonlint" program.
     |      
     |      You can optionally pass options to define the program's environment:
     |      
     |        * program_name  - the name of the program, usually sys.argv[0]
     |        * stdin   - the file object to use for input, default sys.stdin
     |        * stdout  - the file object to use for outut, default sys.stdout
     |        * stderr  - the file object to use for error output, default sys.stderr
     |      
     |      After creating an instance, you typically call the main() method.
     |  
     |  main(self, argv)
     |      The main routine for program "jsonlint".
     |      
     |      Should be called with sys.argv[1:] as its sole argument.
     |      
     |      Note sys.argv[0] which normally contains the program name
     |      should not be passed to main(); instead this class itself
     |      is initialized with sys.argv[0].
     |      
     |      Use "--help" for usage syntax, or consult the 'usage' member.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  usage
     |      A mutlti-line string containing the program usage instructions.
    
    class utf32(codecs.CodecInfo)
     |  Unicode UTF-32 and UCS4 encoding/decoding support.
     |  
     |  This is for older Pythons whch did not have UTF-32 codecs.
     |  
     |  JSON requires that all JSON implementations must support the
     |  UTF-32 encoding (as well as UTF-8 and UTF-16).  But earlier
     |  versions of Python did not provide a UTF-32 codec, so we must
     |  implement UTF-32 ourselves in case we need it.
     |  
     |  See http://en.wikipedia.org/wiki/UTF-32
     |  
     |  Method resolution order:
     |      utf32
     |      codecs.CodecInfo
     |      __builtin__.tuple
     |      __builtin__.object
     |  
     |  Static methods defined here:
     |  
     |  decode(obj, errors='strict', endianness=None)
     |      Decodes a UTF-32 byte string into a Unicode string.
     |      
     |      Returns tuple (bytearray, num_bytes)
     |      
     |      The errors argument shold be one of 'strict', 'ignore',
     |      'replace', 'backslashreplace', or 'xmlcharrefreplace'.
     |      
     |      The endianness should either be None (for auto-guessing), or a
     |      word that starts with 'B' (big) or 'L' (little).
     |      
     |      Will detect a Byte-Order Mark. If a BOM is found and endianness
     |      is also set, then the two must match.
     |      
     |      If neither a BOM is found nor endianness is set, then big
     |      endian order is assumed.
     |  
     |  encode(obj, errors='strict', endianness=None, include_bom=True)
     |      Encodes a Unicode string into a UTF-32 encoded byte string.
     |      
     |      Returns a tuple: (bytearry, num_chars)
     |      
     |      The errors argument should be one of 'strict', 'ignore', or 'replace'.
     |      
     |      The endianness should be one of:
     |          * 'B', '>', or 'big'     -- Big endian
     |          * 'L', '<', or 'little'  -- Little endien
     |          * None                   -- Default, from sys.byteorder
     |      
     |      If include_bom is true a Byte-Order Mark will be written to
     |      the beginning of the string, otherwise it will be omitted.
     |  
     |  lookup(name)
     |      A standard Python codec lookup function for UCS4/UTF32.
     |      
     |      If if recognizes an encoding name it returns a CodecInfo
     |      structure which contains the various encode and decoder
     |      functions to use.
     |  
     |  utf32be_decode(obj, errors='strict')
     |      Decodes a UTF-32BE (big endian) byte string into a Unicode string.
     |  
     |  utf32be_encode(obj, errors='strict', include_bom=False)
     |      Encodes a Unicode string into a UTF-32BE (big endian) encoded byte string.
     |  
     |  utf32le_decode(obj, errors='strict')
     |      Decodes a UTF-32LE (little endian) byte string into a Unicode string.
     |  
     |  utf32le_encode(obj, errors='strict', include_bom=False)
     |      Encodes a Unicode string into a UTF-32LE (little endian) encoded byte string.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  BOM_UTF32_BE = '\x00\x00\xfe\xff'
     |  
     |  BOM_UTF32_LE = '\xff\xfe\x00\x00'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from codecs.CodecInfo:
     |  
     |  __repr__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from codecs.CodecInfo:
     |  
     |  __new__(cls, encode, decode, streamreader=None, streamwriter=None, incrementalencoder=None, incrementaldecoder=None, name=None)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from codecs.CodecInfo:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from __builtin__.tuple:
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getnewargs__(...)
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |  
     |  __sizeof__(...)
     |      T.__sizeof__() -- size of T in memory, in bytes
     |  
     |  count(...)
     |      T.count(value) -> integer -- return number of occurrences of value
     |  
     |  index(...)
     |      T.index(value, [start, [stop]]) -> integer -- return first index of value.
     |      Raises ValueError if the value is not present.

FUNCTIONS
    decode(txt, strict=False, encoding=None, **kw)
        Decodes a JSON-encoded string into a Python object.
        
        Strictness:
        -----------
        If 'strict' is set to True, then those strings that are not
        absolutely strictly conforming to JSON will result in a
        JSONDecodeError exception.
        
        Unicode decoding:
        -----------------
        The input string can be either a python string or a python unicode
        string (or a byte array in Python 3).  If it is already a unicode
        string, then it is assumed that no character set decoding is
        required.
        
        However, if you pass in a non-Unicode text string (a Python 2
        'str' type or a Python 3 'bytes' or 'bytearray') then an attempt
        will be made to auto-detect and decode the character encoding.
        This will be successful if the input was encoded in any of UTF-8,
        UTF-16 (BE or LE), or UTF-32 (BE or LE), and of course plain ASCII
        works too.
        
        Note though that if you know the character encoding, then you
        should convert to a unicode string yourself, or pass it the name
        of the 'encoding' to avoid the guessing made by the auto
        detection, as with
        
            python_object = demjson.decode( input_bytes, encoding='utf8' )
        
        Optional behaviors:
        -------------------
        Optional keywords arguments must be of the form
            allow_xxxx=True/False
        or
            prevent_xxxx=True/False
        where each will allow or prevent the specific behavior, after the
        evaluation of the 'strict' argument.  For example, if strict=True
        then by also passing 'allow_comments=True' then comments will be
        allowed.  If strict=False then prevent_comments=True will allow
        everything except comments.
        
        Callback hooks:
        ---------------
        You may supply callback hooks by using the hook name as the
        named argument, such as:
            decode_float=decimal.Decimal
        
        See the hooks documentation on the JSON.set_hook() method.
    
    determine_float_precision()
        Returns a tuple (significant_digits, max_exponent) for the float type.
    
    encode(obj, strict=False, compactly=True, escape_unicode=False, encoding=None, encode_namedtuple_as_object=True, **kw)
        Encodes a Python object into a JSON-encoded string.
        
        If 'strict' is set to True, then only strictly-conforming JSON
        output will be produced.  Note that this means that some types
        of values may not be convertable and will result in a
        JSONEncodeError exception.
        
        If 'compactly' is set to True, then the resulting string will
        have all extraneous white space removed; if False then the
        string will be "pretty printed" with whitespace and indentation
        added to make it more readable.
        
        If 'encode_namedtuple_as_object' is True, then objects of type
        namedtuple, or subclasses of 'tuple' that have an _asdict()
        method, will be encoded as an object rather than an array.
        
        CONCERNING CHARACTER ENCODING:
        
        The 'encoding' argument should be one of:
        
            * None - The return will be a Unicode string.
            * encoding_name - A string which is the name of a known
                  encoding, such as 'UTF-8' or 'ascii'.
            * codec - A CodecInfo object, such as as found by codecs.lookup().
                  This allows you to use a custom codec as well as those
                  built into Python.
        
        If an encoding is given (either by name or by codec), then the
        returned value will be a byte array (Python 3), or a 'str' string
        (Python 2); which represents the raw set of bytes.  Otherwise,
        if encoding is None, then the returned value will be a Unicode
        string.
        
        The 'escape_unicode' argument is used to determine which characters
        in string literals must be \u escaped.  Should be one of:
        
            * True  -- All non-ASCII characters are always \u escaped.
            * False -- Try to insert actual Unicode characters if possible.
            * function -- A user-supplied function that accepts a single
                 unicode character and returns True or False; where True
                 means to \u escape that character.
        
        Regardless of escape_unicode, certain characters will always be
        \u escaped. Additionaly any characters not in the output encoding
        repertoire for the encoding codec will be \u escaped as well.
    
    extend_and_flatten_list_with_sep(orig_seq, extension_seq, separator='')
    
    extend_list_with_sep(orig_seq, extension_seq, sepchar='')
    
    skipstringsafe(s, start=0, end=None)
    
    skipstringsafe_slow(s, start=0, end=None)

DATA
    __author__ = 'Deron Meranda <http://deron.meranda.us/>'
    __credits__ = 'Copyright (c) 2006-2014 Deron E. Meranda <http:/.../lic...
    __date__ = '2014-04-13'
    __homepage__ = 'http://deron.meranda.us/python/demjson/'
    __version__ = '1.7'
    content_type = 'application/json'
    file_ext = 'json'
    float_maxexp = 307
    float_sigdigits = 14
    inf = inf
    nan = nan
    neginf = -inf
    undefined = demjson.undefined

VERSION
    1.7

DATE
    2014-04-13

AUTHOR
    Deron Meranda <http://deron.meranda.us/>

CREDITS
    Copyright (c) 2006-2014 Deron E. Meranda <http://deron.meranda.us/>
    
    Licensed under GNU LGPL (GNU Lesser General Public License) version 3.0
    or later.  See LICENSE.txt included with this software.
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>
    or <http://www.fsf.org/licensing/>.


